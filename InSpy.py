#!/usr/bin/python

####################################################################################################################
#                                                                                                                  #
#    This script was created to easily enumerate SOME employees from an organization. Please note that this will   #
#    not harvest all possible employees at a given organization. The script is limited to random employees         #
#    provided by LinkedIn as well as those employees who have a LinkedIn profile.                                  #
#                                                                                                                  #
#    It was originally made to assist with employee enumeration during social engineering assessments.             #
#                                                                                                                  #
#    Author: Jonathan Broche                                                                                       #
#    Contact: jb@gojhonny.com                                                                                      #
#    Version: 1.0                                                                                                  #
#                                                                                                                  #
#    Please report any bugs and/or suggestions to me.                                                              #
#                                                                                                                  #
####################################################################################################################

import urllib, BeautifulSoup, argparse, signal, time, datetime, os

start_time = time.time()

class colors:
    lightblue = "\033[1;36m"
    blue = "\033[1;34m"
    normal = "\033[0;00m"
    red = "\033[1;31m"
    yellow = "\033[1;33m"
    white = "\033[1;37m"
    green = "\033[1;32m"

class Timeout():
    class Timeout(Exception):
        pass
 
    def __init__(self, sec):
        self.sec = sec
 
    def __enter__(self):
        signal.signal(signal.SIGALRM, self.raise_timeout)
        signal.alarm(self.sec)
 
    def __exit__(self, *args):
        signal.alarm(0)
 
    def raise_timeout(self, *args):
        raise Timeout.Timeout()

#----------------------------------------#
#           HARVEST USERS                #
#----------------------------------------#

def inspy_enum(dept, company):
    try:
        dept_dictionary = ['sales', 'hr', 'marketing', 'finance', 'accounting', 'director', 'administrative', 'lawyer', 'marketing', 'it', 'finance']
        employees = {}

        if dept is not None:
            dept_dictionary = [dept.lower()]

        for dd in dept_dictionary:
            print "{}[*]{} Searching for employees working at {} with '{}' in their title".format(colors.lightblue, colors.normal, company, dd)

            try:
                with Timeout(30):
                    page = urllib.urlopen('https://www.linkedin.com/title/{}-at-{}'.format(dd.replace('-', ' '), company.replace('-', ' '))).read()
                    soup = BeautifulSoup.BeautifulSoup(page)
            except Timeout.Timeout:
                print "{}[!]{} Timeout enumerating the {} department".format(colors.red, colors.normal, dd)

            #get employee names
            for n, t in zip(soup.findAll('h3', { "class" : "name" }), soup.findAll('p', { "class" : "headline" })):
                name = u''.join(n.getText()).encode('utf-8')
                title = u''.join(t.getText()).encode('utf-8')

                if not name in employees:
                    employees[name] = title

        return employees
    except Exception as e:
        print "{}[!]{} Error harvesting users. {}".format(colors.red, colors.normal, e)

#----------------------------------------#
#               EMAILS                   #
#----------------------------------------#

def format_email(names, eformat):
    emails = []
    for name in names:
        spaces = []
        for x,y in enumerate(name):
            if ' ' in y:
                spaces.append(x)

        if eformat[:eformat.find('@')] == 'flast':
            emails.append('{}{}{}'.format(name[0], name[(spaces[-1]+1):], eformat[eformat.find('@'):]))
        elif eformat[:eformat.find('@')] == 'lfirst':
            emails.append('{}{}{}'.format(name[spaces[-1]+1], name[0:spaces[0]], eformat[eformat.find('@'):]))
        elif eformat[:eformat.find('@')] == 'first.last':
            emails.append('{}.{}{}'.format(name[0:spaces[0]],  name[(spaces[-1]+1):], eformat[eformat.find('@'):]))
        elif eformat[:eformat.find('@')] == 'last.first':
            emails.append('{}.{}{}'.format(name[(spaces[-1]+1):], name[0:spaces[0]], eformat[eformat.find('@'):]))

    return [e.lower() for e in emails]

#----------------------------------------#
#               OUTPUT                   #
#----------------------------------------#

def output(employees, email, company, ofile):
    counter = 0
    ge, be = {}, {} #good & bad employees
    print '\n'

    if email:
        for k, e in zip(employees, email):
            if company in employees[k].lower():
                if ',' in k:
                     be[e] = '{}, {}'.format(k, employees[k])
                else:
                    ge[e] = '{}, {}'.format(k, employees[k])
                    print "{}[*]{} {}, {}, {}".format(colors.green, colors.normal, k, employees[k], e)
                    counter +=1
    else:
        for k in employees:
            if company in employees[k].lower():
                ge[k] = employees[k]
                print "{}[*]{} {} {}".format(colors.green, colors.normal, k, employees[k])
                counter +=1

    if be:        
        print "\n{}[!]{} The following employees have commas in their names. Their emails were not accurate.".format(colors.red, colors.normal)
        for k in be:           
            print "{}[*]{} {}".format(colors.yellow, colors.normal, be[k])

    if ofile:
        with open(ofile, 'w') as f:
            f.write("\n" + "-" * 69 + "\n" + "InSpy Output" + "\n" + "-" * 69 + "\n\n")
            f.write("\n" + "E-mails" + "\n" + "-" * 25 + "\n\n")

            for k in ge.keys():
                f.write(k+'\n')

            f.write("\n" + "All" + "\n" + "-" * 25 + "\n\n")

            for k in ge:
                f.write('{}, {}\n'.format(ge[k], k))

    print "\n{}[*]{} Done! {}{}{} employees found.".format(colors.lightblue, colors.normal, colors.green, counter,  colors.normal)
    print "{}[*]{} Completed in {:.1f}s\n".format(colors.lightblue, colors.normal, time.time()-start_time)

#----------------------------------------#
#               MAIN                     #
#----------------------------------------#

def main():
    print "\n " + "-" * 69 + "\n " + colors.white + "InSpy v1.0 - LinkedIn User Enumeration, Jonathan Broche (jb@gojhonny.com)\n " + colors.normal + "-" * 69 + "\n "
    parser = argparse.ArgumentParser(description='InSpy returns a list of employees from any given organization by querying LinkedIn')
    parser.add_argument('-c', '--company', required=True, help='Company Name')
    parser.add_argument('-d', '--dept', nargs='?', const='', help='Department or Title to search for. If this is not provided XyZ will search through a predefined list')
    parser.add_argument('-e', '--eformat', nargs='?', const='', help='Email format (modes: first.last, last.first, flast, lastf)')
    parser.add_argument('-o', '--ofile', nargs='?', const='', help='File to output to')
    args = parser.parse_args()

    employees = inspy_enum(args.dept, args.company)

    if args.eformat:        
        if args.eformat.find('@') and args.eformat[:args.eformat.find('@')] in {'flast', 'lfirst', 'first.last', 'last.first'}:
                e = format_email(employees.keys(), args.eformat)
                output(employees, e,args.company.lower(), args.ofile)
        else:
            print "{}[!]{} Please supply a valid email address format (i.e., flast@xyz.com, lfirst@xyz.com, first.last@xyz.com, last.first@xyz.com)".format(colors.red, colors.normal)
    else:
        output(employees,args.eformat,args.company.lower(), args.ofile)

if __name__ == '__main__':
    main()