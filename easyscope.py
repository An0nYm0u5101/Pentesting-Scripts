#!/usr/bin/python

# EasyScope - Making client scopes easy
# This script expands a list of IP addresses based off a 
# set of the provided set of arbitrary IP addresses or compresses
# cidrs.
#
# This script requires the netaddr library, use: "python -m pip install netaddr"
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
# Author:  Jonathan Broche
# Contact: jb@gojhonny.com
# Version: 1.0
# Date:    2015-08-01
#
# usuage: ./easyscope [-r range to list (i.e., two IP addresses to expand)] [-f input file with one IP address/range/CIDR per line to list] [-o outputfile]
# example: ./easyscope -r 192.168.1.1 192.168.3.254 -o range_output.txt

import argparse, os, time, datetime, sys, re
from netaddr import IPNetwork, iter_iprange, cidr_merge
from itertools import count

class colors:
    lightblue = "\033[1;36m"
    lightgrey = "\033[0;37m"
    blue = "\033[1;34m"
    normal = "\033[0;00m"
    red = "\033[1;31m"
    yellow = "\033[1;33m"
    white = "\033[1;37m"
    green = "\033[1;32m"

def validate(ip):
    print "{}[*]{} Validating {}".format(colors.blue, colors.normal, ip)
    if re.match(r'^((\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])$', ip):  
        return True  
    else:
        print "{}[!]{} {} is not a valid IP address.".format(colors.red, colors.normal, ip)
        return False   

def expand_it(iplist):
    results = []
    for ip in iplist:
        if type(ip) is list: #take care of range
            [results.append(address) for address in iter_iprange(sorted(ip)[0], sorted(ip)[1])]
        else: #expand cidr
            for address in ip:
                results.append(address)
    return results

def compress_it(iplist):
    try:
        cidr_merge(iplist)
        return cidr_merge(iplist)
    except (ValueError, TypeError):
        print "{}[!]{} Ensure that all IPs are in CIDR notation.".format(colors.red, colors.normal)
 
def output(results, outfile):
    print "\nResults are here! Standby...\n"
    if outfile is None:
        for ip in results:
            print ip
        print "\n{}[*]{} Done!".format(colors.blue, colors.normal)
    else:
        with open(os.path.join(os.getcwd(), outfile), 'w') as f:
            for ip in results:
                f.write(str(ip))
            print "\n{}[*]{} Done! Results written to {}".format(colors.blue, colors.normal, os.path.join(os.getcwd(), outfile))

def main():
    stime = time.time()

    parser = argparse.ArgumentParser(description="EasyScope by Jonathan Broche (@g0jhonny)")
    parser.add_argument('-r', '--range', help='A set of two IPs', nargs=2)
    parser.add_argument('-f', '--file', help='File containing one subnet (e.g., 192.168.1.1/24) or IP range (e.g. 192.168.1.1-192.168.1.254) per line.')
    parser.add_argument('-o', '--outfile', help='File to write results to.')
    action = parser.add_mutually_exclusive_group(required=True)
    action.add_argument('-e', '--expand', action='store_true', help='Expand IPs')
    action.add_argument('-c', '--compress', action='store_true', help='Compress IPs/CIDRs')    
    args = parser.parse_args()

    results, iplist = [], []

    print "\n" + "-" * 70 + "\n" + colors.white + " EasyScope v1.0 by Jonathan Broche (@g0jhonny.com)\n" + colors.normal + "-" * 70 + "\n"

    try:        
        if args.range or args.file:
            if args.range:
                for ip in args.range:
                    if not validate(ip.strip()):
                        return   
                    elif args.compress: 
                        iplist.append(IPNetwork(ip.strip()))
        
                if args.expand: iplist.append(args.range)
            if args.file:
                with open (args.file) as f:
                    lines = f.readlines()
                for ip in lines:
                    if '-' in ip: #if dash(range)
                        for address in ip.split('-'):
                            if not validate(address.strip()):
                                return
                        if args.compress:                            
                            [iplist.append(IPNetwork(address)) for address in expand_it([ip.strip().split('-')])]
                        else: iplist.append(ip.strip().split('-'))

                    elif '/' in ip and validate(ip.split('/', 1)[0]): #if cidr
                        iplist.append(IPNetwork(ip.strip()))
                    else:
                        if validate(ip.strip()): #if ip per line
                            iplist.append(IPNetwork(ip.strip()))
        else:
            print "{}[!]{} No scope provided, add an IP range [-r range] and/or file [-f file] to parse through\n".format(colors.red, colors.normal)
            return

        if args.expand:
            print iplist
            results = expand_it(iplist)
        elif args.compress:
            results = compress_it(iplist)
        else:
            print "{}[!]{} No action provided, add -c to compress IPs or -e to expand them\n".format(colors.red, colors.normal)
            return

        if args.outfile:
            output(results, args.outfile)
        else:
            output(results, None)
    
        print "{}[*]{} Completed in {:.2f}s\n".format(colors.green, colors.normal, time.time()- stime)   

    except Exception as e:
        print "{}[!]{} Oh Bits! There was an error: {}\n".format(colors.red, colors.normal, e)
    except IOError:
        print "{}[!]{} File: {} does not exist\n".format(colors.red, colors.normal, args.file)

if __name__ == '__main__':
    main()